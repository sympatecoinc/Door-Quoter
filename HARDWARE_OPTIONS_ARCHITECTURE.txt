================================================================================
HARDWARE OPTIONS ARCHITECTURE - VISUAL REFERENCE
================================================================================

DATABASE LAYER
==============

IndividualOption (IndividualOptions table)
  ├── id: number
  ├── categoryId: number (FK)
  ├── name: string (e.g., "Chrome Handle")
  ├── description: string?
  └── price: float ◄─── KEY: Hardware option cost
      
ComponentInstance (ComponentInstances table)
  ├── id: number
  ├── panelId: number (1:1 unique)
  ├── productId: number
  └── subOptionSelections: string
      └── JSON: { "categoryId": optionId, ... }
      
SubOptionCategory (SubOptionCategories table)
  ├── id: number
  ├── name: string (e.g., "Handle Type")
  ├── description: string?
  └── individualOptions: IndividualOption[]
  
ProductSubOption (ProductSubOptions table)
  ├── productId: number
  ├── categoryId: number
  └── Unique constraint: [productId, categoryId]

================================================================================

API ENDPOINTS FLOW
==================

CREATE COMPONENT WITH OPTIONS:
  POST /api/component-instances
  │
  ├─ Input: { panelId, productId, subOptionSelections: {3: 5, 4: 8} }
  ├─ Validate panel & product existence
  ├─ Store: subOptionSelections = JSON.stringify({3: 5, 4: 8})
  └─ Return: ComponentInstance with product & panel

UPDATE COMPONENT OPTIONS:
  PUT /api/component-instances/[id]
  │
  ├─ Input: { subOptionSelections: {3: 12, 4: 9} }
  ├─ Update: subOptionSelections = JSON.stringify({3: 12, 4: 9})
  └─ Return: Updated ComponentInstance

CALCULATE OPENING PRICE:
  POST /api/openings/[id]/calculate-price
  │
  ├─ Fetch opening with all panels & component instances
  ├─ For each component:
  │  ├─ Add BOM costs
  │  ├─ Parse subOptionSelections JSON
  │  ├─ For each selected option:
  │  │  └─ Find IndividualOption.price → Add to totalComponentCost
  │  └─ Add glass costs
  ├─ Store: Opening.price = totalComponentCost
  └─ Return: Detailed price breakdown with option costs

GENERATE QUOTE:
  GET /api/projects/[id]/quote
  │
  ├─ Fetch project with all openings & components
  ├─ For each opening:
  │  ├─ Parse subOptionSelections
  │  ├─ Build hardware items list with prices
  │  ├─ Calculate: hardwarePrice = sum of selected IndividualOption.price
  │  ├─ Apply category markup (hardwareMarkup) if PricingMode exists
  │  └─ Return: quoteItem with hardware array & price
  └─ Return: Quote with all items & totals

================================================================================

FRONTEND UI LAYER
=================

ProjectDetailView.tsx
│
├─ Component List View (lines 1119-1170)
│  │
│  └─ Display: "Handle Type: Chrome Handle"
│            "Lock Type: Electronic Lock"
│     (For each selected option in subOptionSelections)
│
└─ Component Edit Modal (lines 1538-1710)
   │
   ├─ State: selectedOptions = { categoryId: optionId, ... }
   │
   ├─ Load Options:
   │  ├─ Fetch: GET /api/products/[productId]
   │  ├─ Get: product.productSubOptions[]
   │  └─ For each: show category.individualOptions[] in dropdown
   │
   ├─ Display Dropdown (lines 1579-1612):
   │  │
   │  ├─ <select value={selectedOptions[categoryId] || ''}>
   │  │  ├─ <option value="">Select option...</option>
   │  │  └─ For each individualOption:
   │  │      <option value={id}>
   │  │        {name}
   │  │        {price > 0 && ` (+${price})`}
   │  │      </option>
   │  └─ onChange: setSelectedOptions({...selectedOptions, [catId]: optionId})
   │
   └─ Save Changes (lines 1627-1710):
      │
      ├─ PATCH /api/panels/[panelId] (dimensions)
      ├─ PATCH /api/components/[componentId]
      │  └─ Body: { subOptionSelections: selectedOptions }
      ├─ POST /api/openings/[openingId]/calculate-price
      └─ Show success toast

================================================================================

PRICING CALCULATION FLOW
========================

Component Cost Calculation:
  
  totalComponentCost = 0
  
  1. Add BOM costs:
     for each ProductBOM {
       totalComponentCost += calculateBOMItemPrice(bom, width, height)
     }
  
  2. Add Hardware Option costs:
     Parse: options = JSON.parse(subOptionSelections)
     for each [categoryId, optionId] in options {
       IndividualOption = find by optionId
       totalComponentCost += IndividualOption.price  ◄─── KEY OPERATION
       optionCosts.push({ name, price })
     }
  
  3. Add Glass costs:
     if glassType {
       totalComponentCost += calculateGlassCost(panel, glassType)
     }

Opening.price = sum of all component costs

Quote Price with Markup:

  For category-specific pricing:
    hardwareCost = sum of all hardware options prices
    markedUpPrice = hardwareCost × (1 + hardwareMarkup/100) × (1 - discount/100)
    
  Quote displays:
    Hardware items: [
      { name: "Handle Type: Chrome", price: 45.50 },
      { name: "Lock Type: Electronic", price: 125.00 }
    ]
    Total marked-up price: (45.50 + 125.00) × markup factor

================================================================================

DATA TRANSFORMATION PIPELINE
============================

Step 1: USER SELECTION (Frontend)
  User selects in dropdown:
    categoryId: 3, optionId: 5
  │
  └─> React State: { selectedOptions: { 3: 5 } }

Step 2: SERIALIZATION (API Request)
  selectedOptions = { 3: 5 }
  │
  └─> JSON.stringify(selectedOptions) = '{"3":5}'
  
Step 3: DATABASE STORAGE
  ComponentInstance.subOptionSelections = '{"3":5}'
  │
  └─> PostgreSQL: String column

Step 4: DESERIALIZATION (Price Calculation)
  JSON.parse('{"3":5}') = { "3": 5 }
  │
  ├─> For each [categoryId, optionId]:
  │   ├─ Find IndividualOption(id=5)
  │   └─ Add IndividualOption.price to cost
  │
  └─> Result: componentBreakdown.optionCosts[]

Step 5: QUOTE GENERATION
  Quote endpoint fetches componentInstance.subOptionSelections
  │
  ├─> Parse JSON
  ├─> Resolve option names & prices
  ├─> Format as: "Handle Type: Chrome Handle (+$45.50)"
  ├─> Sum prices: hardwarePrice = $45.50
  │
  └─> Display in quote with markup applied

================================================================================

MODIFICATION CHECKLIST
======================

To ADD a new hardware option to a product:

  [ ] Create IndividualOption:
      - Name: "Option Name"
      - categoryId: (existing SubOptionCategory.id)
      - price: 45.50

  [ ] Ensure ProductSubOption exists for:
      - productId: (target product)
      - categoryId: (category from IndividualOption)

  [ ] Test:
      - Open component edit modal
      - Should see new option in dropdown with price
      - Select it
      - Save
      - Price calculation should include option price
      - Quote should show it in hardware items

To CHANGE an option price:

  [ ] Update IndividualOption.price
  [ ] Recalculate affected opening prices
  [ ] Quote will automatically show new price

To CHANGE option selection:

  [ ] User edits component
  [ ] Selects different option (or null for no selection)
  [ ] Save button:
      - PATCHes component with new subOptionSelections
      - Recalculates opening price
      - Cost automatically includes new option price

To DISPLAY option in quote:

  [ ] Already implemented in /api/projects/[id]/quote/route.ts
  [ ] No changes needed
  [ ] Quote automatically extracts and displays from subOptionSelections

================================================================================

CRITICAL LOOKUPS
================

ComponentInstance.subOptionSelections "3" → IndividualOption id 5:

  ComponentInstance {
    subOptionSelections: '{"3":5}'
  }
  
  JSON.parse('{"3":5}') = { "3": 5 }
  
  lookup: categoryId=3, optionId=5
  
  SubOptionCategory.id = 3
    └─> IndividualOption[] {
          { id: 5, name: "Chrome Handle", price: 45.50 } ◄── MATCH
        }

  Result: IndividualOption { id: 5, price: 45.50 }

================================================================================
